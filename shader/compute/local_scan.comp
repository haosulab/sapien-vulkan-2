#version 450
#extension GL_KHR_shader_subgroup_shuffle_relative: enable
#extension GL_EXT_debug_printf: enable

layout(local_size_x_id = 0) in;

layout (constant_id = 3) const int subgroupSize = 32;

layout(std430, push_constant) uniform Constants {
  int count;
};

layout(std430, set = 0, binding = 0) buffer InputBuffer0 {
  float data[];
};

layout(std430, set = 0, binding = 1) buffer InputBuffer1 {
  float sum[];
};

shared float temp[subgroupSize];

float local_scan() {
  uint tid = gl_LocalInvocationID.x;
  float tmp0, tmp1, tmp2;

  uint gid = gl_WorkGroupID.x * gl_WorkGroupSize.x + tid;

  // scan subgroups
  tmp0 = gid < count ? data[gid] : 0.0;
  for (int d = 1; d < subgroupSize; d = 2 * d) {
    tmp1 = subgroupShuffleUp(tmp0, d);
    if (gl_SubgroupInvocationID >= d) {
      tmp0 += tmp1;
    }
  }

  // store sum of each subgroup into local variable temp
  if (gl_SubgroupInvocationID == subgroupSize - 1) {
    temp[tid / subgroupSize] = tmp0;
  }

  barrier();

  // scan subgroup sums
  // TODO: assume # subgroups per group < subgroup size
  if (tid < subgroupSize) {
    tmp1 = 0.0;
    if (tid < gl_WorkGroupSize.x / subgroupSize) {
      tmp1 = temp[tid];
    }
    for (int d = 1; d < subgroupSize; d = 2 * d) {
      tmp2 = subgroupShuffleUp(tmp1, d);
      if (gl_SubgroupInvocationID >= d) {
        tmp1 += tmp2;
      }
    }
    if (tid < gl_WorkGroupSize.x / subgroupSize) {
      temp[tid] = tmp1;
    }
  }

  barrier();
  if (tid >= subgroupSize) {
    tmp0 += temp[tid / subgroupSize - 1];
  }

  return tmp0;
}

void main() {
  uint gid = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
  float local = local_scan();
  if (gl_LocalInvocationID.x == gl_WorkGroupSize.x - 1) {
    sum[gl_WorkGroupID.x] = local;
  }
  if (gid < count) {
    data[gid] = local;
  }
}
